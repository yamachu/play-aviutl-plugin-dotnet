using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AviUtlPluginNet.SourceGenerator
{
    [Generator]
    public class AviUtlPluginSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // AviUtl2InputPluginAttributeが付いたクラスを検索
            var pluginClasses = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (s, _) => IsPluginClass(s),
                    transform: (ctx, _) => GetPluginClassInfo(ctx))
                .Where(m => m != null)
                .Collect();

            context.RegisterSourceOutput(pluginClasses, Execute);
        }

        private static bool IsPluginClass(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDeclaration &&
                   classDeclaration.AttributeLists.Count > 0;
        }

        private static PluginClassInfo? GetPluginClassInfo(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var semanticModel = context.SemanticModel;

            // クラスのシンボルを取得
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
            if (classSymbol == null) return null;

            // AviUtl2InputPluginAttributeが付いているかチェック
            var hasAttribute = classSymbol.GetAttributes()
                .Any(attr => attr.AttributeClass?.Name == "AviUtl2InputPluginAttribute");

            if (!hasAttribute) return null;

            // 実装しているインターフェースを検索
            var implementedInterface = FindInputPluginInterface(classSymbol);
            if (implementedInterface == null) return null;

            // IWithoutConfigを実装しているかチェック
            var implementsWithoutConfig = classSymbol.AllInterfaces
                .Any(i => i.Name == "IWithoutConfig");

            return new PluginClassInfo(
                classSymbol.Name,
                classSymbol.ContainingNamespace?.ToDisplayString() ?? "",
                implementedInterface.Name,
                implementedInterface.TypeArguments.FirstOrDefault()?.Name ?? "IInputHandle",
                implementsWithoutConfig
            );
        }

        private static INamedTypeSymbol? FindInputPluginInterface(INamedTypeSymbol classSymbol)
        {
            return classSymbol.AllInterfaces
                .FirstOrDefault(i => i.Name.StartsWith("IInput") && i.Name.Contains("Plugin"));
        }

        private static void Execute(SourceProductionContext context, ImmutableArray<PluginClassInfo?> pluginClasses)
        {
            foreach (var pluginClass in pluginClasses)
            {
                if (pluginClass == null) continue;

                // partial classの拡張（コンストラクタ）を生成
                GeneratePartialClass(context, pluginClass);

                // NativeLibraryクラスを生成
                GenerateNativeLibraryClass(context, pluginClass);
            }
        }

        private static void GeneratePartialClass(SourceProductionContext context, PluginClassInfo pluginClass)
        {
            var source = $@"// <auto-generated/>
#nullable enable
using System;
using System.Runtime.InteropServices;
using AviUtlPluginNet.Abstractions;

namespace {pluginClass.Namespace}
{{
    partial class {pluginClass.ClassName}
    {{
        public unsafe {pluginClass.ClassName}(
            delegate* unmanaged[Stdcall]<IntPtr, IntPtr> funcOpen,
            delegate* unmanaged[Stdcall]<IntPtr, bool> funcClose,
            delegate* unmanaged[Stdcall]<IntPtr, IntPtr, bool> funcInfoGet,
            delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int> funcReadVideo,
            delegate* unmanaged[Stdcall]<IntPtr, int, int, IntPtr, int> funcReadAudio,
            delegate* unmanaged[Stdcall]<IntPtr, IntPtr, bool> funcConfig
        ) : this()
        {{
            {pluginClass.InterfaceName}<{pluginClass.HandleTypeName}>.InitPluginTable<{pluginClass.ClassName}>(
                funcOpen,
                funcClose,
                funcInfoGet,
                funcReadVideo,
                funcReadAudio,
                funcConfig
            );
        }}
    }}
}}
";

            context.AddSource($"{pluginClass.ClassName}.Constructor.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        private static void GenerateNativeLibraryClass(SourceProductionContext context, PluginClassInfo pluginClass)
        {
            var nativeLibraryClassName = $"{pluginClass.ClassName}NativeLibrary";

            var source = $@"// <auto-generated/>
#nullable enable
using System;
using System.Runtime.InteropServices;
using System.Buffers;
using AviUtlPluginNet.Abstractions;
using AviUtlPluginNet.Core.Interop.AUI2;

namespace {pluginClass.Namespace}
{{
    public static unsafe class {nativeLibraryClassName}
    {{
        private static readonly {pluginClass.ClassName} plugin = new {pluginClass.ClassName}(
            &FuncOpen,
            &FuncClose,
            &FuncInfoGet,
            &FuncReadVideo,
            &FuncReadAudio,
            {(pluginClass.IsWithoutConfig ? "null" : "&FuncConfig")}
        );

        [UnmanagedCallersOnly(EntryPoint = ""GetInputPluginTable"", CallConvs = new[] {{ typeof(System.Runtime.CompilerServices.CallConvStdcall) }})]
        public static IntPtr GetInputPluginTable()
        {{
            _ = plugin; // プラグインの初期化を強制的に行う
            return {pluginClass.InterfaceName}<{pluginClass.HandleTypeName}>.GetPluginTablePtr<{pluginClass.ClassName}>();
        }}

        [UnmanagedCallersOnly(CallConvs = new[] {{ typeof(System.Runtime.CompilerServices.CallConvStdcall) }})]
        public static IntPtr FuncOpen(IntPtr file)
        {{
            try
            {{
                // AviUtlから渡されたファイルパス（UTF-16）を取得
                string? path = Marshal.PtrToStringUni(file);
                if (string.IsNullOrEmpty(path))
                {{
                    return IntPtr.Zero;
                }}
                var handle = plugin.FuncOpen(path);
                if (handle == null)
                {{
                    return IntPtr.Zero;
                }}
                var gch = GCHandle.Alloc(handle);
                return (IntPtr)gch;
            }}
            catch
            {{
                return IntPtr.Zero;
            }}
        }}

        [UnmanagedCallersOnly(CallConvs = new[] {{ typeof(System.Runtime.CompilerServices.CallConvStdcall) }})]
        public static bool FuncClose(IntPtr ih)
        {{
            if (ih == IntPtr.Zero) return false;
            var gch = (GCHandle)ih;
            if (gch.Target is IInputHandle handle)
            {{
                (plugin as {pluginClass.InterfaceName}<{pluginClass.HandleTypeName}>).FuncClose(handle);
                gch.Free();
                return true;
            }}
            return false;
        }}

        [UnmanagedCallersOnly(CallConvs = new[] {{ typeof(System.Runtime.CompilerServices.CallConvStdcall) }})]
        public static bool FuncInfoGet(IntPtr ih, IntPtr iip)
        {{
            if (ih == IntPtr.Zero || iip == IntPtr.Zero) return false;
            var gch = (GCHandle)ih;
            if (gch.Target is not IInputHandle handle) return false;

            if ((plugin as {pluginClass.InterfaceName}<{pluginClass.HandleTypeName}>).FuncInfoGet(handle, out var i) == false)
            {{
                return false;
            }}

            if (i.HasValue)
            {{
                unsafe
                {{
                    var info = (INPUT_INFO*)iip;
                    info->flag = i.Value.flag;
                    info->rate = i.Value.rate;
                    info->scale = i.Value.scale;
                    info->n = i.Value.n;
                    info->format = i.Value.format;
                    info->format_size = i.Value.format_size;
                    info->audio_n = i.Value.audio_n;
                    info->audio_format = i.Value.audio_format;
                    info->audio_format_size = i.Value.audio_format_size;
                }}
            }}
            return true;
        }}

        [UnmanagedCallersOnly(CallConvs = new[] {{ typeof(System.Runtime.CompilerServices.CallConvStdcall) }})]
        public static int FuncReadVideo(IntPtr ih, int frame, IntPtr buf)
        {{
            if (ih == IntPtr.Zero || buf == IntPtr.Zero) return 0;
            var gch = (GCHandle)ih;
            if (gch.Target is not IInputHandle handle) return 0;

            var pixels = (plugin as {pluginClass.InterfaceName}<{pluginClass.HandleTypeName}>).FuncReadVideo(handle, frame);

            // Copy directly from the span to the unmanaged buffer
            if (!pixels.IsEmpty)
            {{
                unsafe
                {{
                    var dst = (byte*)buf;
                    fixed (byte* src = pixels)
                    {{
                        Buffer.MemoryCopy(src, dst, pixels.Length, pixels.Length);
                    }}
                }}
            }}
            return pixels.Length;
        }}

        [UnmanagedCallersOnly(CallConvs = new[] {{ typeof(System.Runtime.CompilerServices.CallConvStdcall) }})]
        public static int FuncReadAudio(IntPtr ih, int start, int length, IntPtr buf)
        {{
            if (ih == IntPtr.Zero || buf == IntPtr.Zero) return 0;
            var gch = (GCHandle)ih;
            if (gch.Target is not IInputHandle handle) return 0;

            var audio = (plugin as {pluginClass.InterfaceName}<{pluginClass.HandleTypeName}>).FuncReadAudio(handle, start, length);
            if (audio.IsEmpty) return 0;

            // Copy directly from the span to the unmanaged buffer
            unsafe
            {{
                var dst = (byte*)buf;
                fixed (byte* src = audio)
                {{
                    Buffer.MemoryCopy(src, dst, audio.Length, audio.Length);
                }}
            }}
            return audio.Length;
        }}
{(pluginClass.IsWithoutConfig ? "" : $@"
        [UnmanagedCallersOnly(CallConvs = new[] {{ typeof(System.Runtime.CompilerServices.CallConvStdcall) }})]
        public static bool FuncConfig(IntPtr hwnd, IntPtr hInstance)
        {{
            return (plugin as {pluginClass.InterfaceName}<{pluginClass.HandleTypeName}>).FuncConfig(hwnd, hInstance);
        }}")}
    }}
}}
";

            context.AddSource($"{nativeLibraryClassName}.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    public class PluginClassInfo
    {
        public string ClassName { get; }
        public string Namespace { get; }
        public string InterfaceName { get; }
        public string HandleTypeName { get; }
        public bool IsWithoutConfig { get; }

        public PluginClassInfo(string className, string namespaceName, string interfaceName, string handleTypeName, bool isWithoutConfig = false)
        {
            ClassName = className ?? "";
            Namespace = namespaceName ?? "";
            InterfaceName = interfaceName ?? "";
            HandleTypeName = handleTypeName ?? "";
            IsWithoutConfig = isWithoutConfig;
        }
    }
}

// TODO: Rename and impl output plugin generator